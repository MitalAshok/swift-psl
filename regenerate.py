import sys
import os
import time
import argparse
import collections

import urllib.request


_REDOWNLOAD_INTERVAL = 12 * 60 * 60  # Every half of a day


_dir = os.path.dirname(os.path.realpath(__file__))
_DEFAULT_PSL = os.path.join(_dir, 'public_suffix_list.dat')
_PSL_URL = 'https://publicsuffix.org/list/public_suffix_list.dat'


def get_public_suffixes(psl_file):
    positive_public_suffixes = []
    negative_public_suffixes = []
    with open(psl_file, encoding='utf-8') as f:
        for line in f:
            line = line.split(maxsplit=1)
            if not line:
                continue
            line = line[0]
            if not line or line.startswith('//'):
                continue
            if line.startswith('!'):
                line = line[1:]
                l = negative_public_suffixes
            else:
                l = positive_public_suffixes
            l.append(line.strip('.').lower().split('.'))
    return tuple(positive_public_suffixes), tuple(negative_public_suffixes)


def need_to_redownload_psl(psl_file, current_timestamp):
    try:
        f = open(psl_file, 'rb')
    except OSError:
        return True
    else:
        try:
            if f.read(3) != b'// ':
                return True
            timestamp = f.read(20)
        finally:
            f.close()
    timestamp_end = timestamp.find(b'\n')
    if timestamp_end == -1:
        return True
    timestamp = timestamp[:timestamp_end]
    if not timestamp.isdigit():
        return True
    timestamp = int(timestamp.decode('ascii'))
    return (
        timestamp > current_timestamp + 60 * 60 or  # More than an hour in the future.
        current_timestamp - timestamp > _REDOWNLOAD_INTERVAL  # More than _REDOWNLOAD_INTERVAL has passed
    )


def redownload_psl(psl_file, current_timestamp):
    r = urllib.request.urlopen(_PSL_URL)
    header = b'// ' + str(int(current_timestamp)).encode('ascii') + b'\n'
    with open(psl_file, 'wb') as f:
        f.write(header)
        while True:
            chunk = r.read(10 * 1024)
            if not chunk:
                break
            f.write(chunk)


def rules_to_tree(rules):
    tree = collections.OrderedDict()
    for rule in rules:
        rule_tree = tree
        for label in reversed(rule):
            rule_tree = rule_tree.setdefault(label, collections.OrderedDict())
        rule_tree['!'] = True
    return tree

_CONSTANT_NAMES = {
    '!': 'accept_this',
    '*': 'wildcard'
}

def to_swift_string(s):
    return _CONSTANT_NAMES.get(s, None) or '"{}"'.format(s)

def make_swift_dict(name, d, callback, *, prior=()):
    dest = name
    for label in prior:
        dest = '(' + dest + '[' + to_swift_string(label) + '] as [String: Any])'
    for k, v in d.items():
        this_dest = dest + '[' + to_swift_string(k) + ']'
        if isinstance(v, dict):
            callback(this_dest + ' = [String: Any]()\n')
            make_swift_dict(name, v, callback, prior=prior + (k,))
        elif isinstance(v, bool):
            callback(this_dest + ' = ' + ['false', 'true'][v] + '\n')
        else:
            raise TypeError('Unexpected value: ' + repr(value))

def main(argv=None):
    if argv is None:
        argv = sys.argv[1:]

    parser = argparse.ArgumentParser(prog='regenerate_public_suffix_list')
    parser.add_argument(metavar='SWIFT FILE', dest='swift_file', help='.swift file to write to')
    parser.add_argument(metavar='PUBLIC SUFFIX LIST', dest='psl_file', help='The public suffix list. Defaults to "public_suffix_list.dat" in the same directory as this python file.', default=_DEFAULT_PSL, nargs='?')

    args = parser.parse_args(argv)

    swift_file = args.swift_file
    psl_file = args.psl_file

    current_timestamp = int(time.time())

    if need_to_redownload_psl(psl_file, current_timestamp):
        print('Redownloading public suffix list.')
        redownload_psl(psl_file, current_timestamp)
        print('Done downloading.')
    else:
        print('Not redownloading public suffix list.')
        if os.path.exists(swift_file):
            print('Not regenerating swift file as it already exits.')
            return

    print('Reading public suffix list file.')
    positive_public_suffixes, negative_public_suffixes = get_public_suffixes(psl_file)

    print('Regenerating swift file.')
    
    with open(swift_file, 'w', encoding='utf-8') as f:
        f.write(
'''
// Autogenerated at {timestamp}

fileprivate let accept_this = "!"
fileprivate let wildcard = "*"

fileprivate var _p_suffixes: [String: Any] = [String: Any]()
fileprivate var _n_suffixes: [String: Any] = [String: Any]()

// This section is compiled from the public suffix list.
// TEMPLATE SECTION

'''.strip('\n').format(timestamp=current_timestamp) + '\n\n'

            )

        make_swift_dict('_p_suffixes', rules_to_tree(positive_public_suffixes), f.write)
        f.write('\n\n')
        make_swift_dict('_n_suffixes', rules_to_tree(negative_public_suffixes), f.write)

        f.write(
'''
// END TEMPLATE SECTION

fileprivate let p_suffixes = _p_suffixes
fileprivate let n_suffixes = _n_suffixes

_p_suffixes = _n_suffixes = [String: Any]()

func get_domain(hostname: String) -> String? {
    let labels = domain.compenents(seperatedBy: ".").reversed()

    var longest: Array<String> = Array<String>()
    var this_longest: Array<String> = Array<String>()

    // Check negative rules

    var accepted_rules: Array<[String: Any]> = [n_suffixes]

    for label in labels {
        if (!label) {
            return nil
        }
        this_longest.append(label)
        var new_accepted_rules: Array<[String: Any]> = Array<[String: Any]>()
        for rule in accepted_rules {
            if (rule[accept_this]) {
                longest = this_longest
            }
            if let wildcard_rule = rule[wildcard] as [String: Any] {
                new_accepted_rules.append(wildcard_rule)
            }
            if let label_rule = rule[label] as [String: Any] {
                new_accepted_rules.append(label_rule)
            }
        }
        accepted_rules = new_accepted_rules
    }
    
    if (longest.count != 0) {
        return longest.reversed().joined(seperator: ".")
    }
    
    // Check positive rules
    
    longest = []
    this_longest = [labels[0]]
    
    accepted_rules: Array<[String: Any]> = [p_suffixes]

    for next_label in labels.dropFirst() {
        let label = this_longest[this_longest.length - 1]
        this_longest.append(next_label)
        var new_accepted_rules = Array<[String: Any]>()
        for rule in accepted_rules {
            if (rule[accept_this]) {
                longest = this_longest
            }
            if let wildcard_rule = rule[wildcard] as [String: Any] {
                new_accepted_rules.append(wildcard_rule)
            }
            if let label_rule = rule[label] as [String: Any] {
                new_accepted_rules.append(label_rule)
            }
        }
        accepted_rules = new_accepted_rules
    }
    
    for rule in accepted_rules {
        if (rule[accept_this]) {
            // Given domain is a TLD. e.g. "com" or "co.uk" was given.
            return nil
        }
    }
    
    if (longest.count != 0) {
        return longest.reversed().joined(seperator: ".")
    }
    
    // If no rules match, the rule is just "*".
    
    if (labels.count < 2) {
        return nil
    }

    return labels[1] + '.' + labels[0]
}

'''.strip('\n') + '\n\n'
            )
            
    globals().update(locals())
    globals().update({
        'p_tree': rules_to_tree(positive_public_suffixes),
        'n_tree': rules_to_tree(negative_public_suffixes)
    })


if __name__ == '__main__':
    main()
